package weka.filters.unsupervised.instance;

import weka.core.*;
import weka.filters.SimpleBatchFilter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

public class Smear extends SimpleBatchFilter implements Randomizable {
    /**
     * Seed for random number generation.
     */
    protected int m_seed = 0;

    /**
     * Standard deviation to use for the normal distribution.
     */
    protected double m_stdDev = 0.5;

    /**
     * Number of instances in new training set relative to number of instances in input training set.
     */
    protected double m_numSamples = 1;

    /**
     * The method used to establish the format of the data generated by this filter, as an Instances object.
     *
     * @param instances the input dataset, with a string attribute containing the file names of the images
     * @return an Instances object that provides the "header" information for the data generated by this filter
     * (i.e., an Instances object that does not contain any actual instances but does contain a list of attributes).
     */
    @Override
    protected Instances determineOutputFormat(Instances instances) {
        // create attribute list
        ArrayList<Attribute> attributes = new ArrayList<>(instances.numAttributes());
        // copy attributes from input
        for (int i = 0; i < instances.numAttributes(); i++) {
            attributes.add(instances.attribute(i));
        }

        // create and return output
        Instances output = new Instances("features", attributes, 0);
        output.setClassIndex(output.numAttributes() - 1);
        return output;
    }

    /**
     * The method that processes the given dataset and outputs the filtered data.
     *
     * @param instances the input data to be filtered, with a string attribute containing the file names of the images
     * @return the filtered data, consisting of feature vectors ready for other machine learning algorithms
     */
    @Override
    protected Instances process(Instances instances) {
        // return the instances if not training instances
        if (isFirstBatchDone())
            return instances;

        Random rnd = new Random(m_seed);
        int numInput = instances.numInstances();
        int numOutput = (int) (numInput * m_numSamples);
        Instances output = getOutputFormat();

        // get attribute multipliers
        final int k = 10;
        double[] attributeMultipliers = new double[instances.numAttributes()];
        // for each attribute
        for (int i = 0; i < instances.numAttributes(); i++) {
            // skip class index
            if (i == output.classIndex())
                continue;

            double[] valuesForAttribute = instances.attributeToDoubleArray(0);

            // sort
            Arrays.sort(valuesForAttribute);

            // calculate difference between adjacent values
            List<Double> diffs = new ArrayList();
            for (int j = 0; j < valuesForAttribute.length - 1; j++) {
                double diff = valuesForAttribute[j + 1] - valuesForAttribute[j];
                // ignore 0s
                if (diff != 0)
                    diffs.add(diff);
            }

            // sort
            diffs.sort(Double::compareTo);

            // take kth smallest
            if (diffs.size() > k)
                attributeMultipliers[i] = diffs.get(k - 1);
                // if not k values, take largest
            else if (diffs.size() != 0)
                attributeMultipliers[i] = diffs.get(diffs.size() - 1);
                // if no values, make 0
            else
                attributeMultipliers[i] = 0;
        }

        // for number of expected outputs
        for (int i = 0; i < numOutput; i++) {
            // create feature array
            double[] features = new double[output.numAttributes()];

            double[] sample = instances.get(rnd.nextInt(numInput)).toDoubleArray();

            // jitter features
            for (int j = 0; j < output.numAttributes(); j++) {
                // skip class index
                if (j == output.classIndex())
                    continue;

                double jitter = rnd.nextGaussian() * m_stdDev * attributeMultipliers[j];

                features[j] = sample[j] + jitter;
            }

            features[output.classIndex()] = sample[output.classIndex()];
            output.add(new DenseInstance(1, features));
        }

        return output;
    }

    @Override
    public String globalInfo() {
        return "This filter randomizes training data using the smear method.";
    }

    @OptionMetadata(
            displayName = "Seed for random number generation",
            description = "The seed value used by the random number generator.",
            displayOrder = 1,
            commandLineParamName = "S",
            commandLineParamSynopsis = "-S")
    @Override
    public int getSeed() {
        return m_seed;
    }

    @Override
    public void setSeed(int seed) {
        m_seed = seed;
    }

    @OptionMetadata(
            displayName = "Standard deviation to use for the normal distribution.",
            description = "The standard deviation to use for the normal distribution.",
            displayOrder = 2,
            commandLineParamName = "stdDev",
            commandLineParamSynopsis = "-stdDev")
    public double getStdDev() {
        return m_stdDev;
    }

    public void setStdDev(double stdDev) {
        m_stdDev = stdDev;
    }

    @OptionMetadata(
            displayName = "Number of instances in new training set relative to number of instances in input training set.",
            description = "The number of instances in new training set relative to number of instances in input training set.",
            displayOrder = 3,
            commandLineParamName = "numSamples",
            commandLineParamSynopsis = "-numSamples")
    public double getNumSamples() {
        return m_numSamples;
    }

    public void setNumSamples(double numSamples) {
        m_numSamples = numSamples;
    }

    public static void main(String[] args) {
        runFilter(new Smear(), args);
    }
}
